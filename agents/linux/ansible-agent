#!/bin/bash
#
# Ansible Agent for Linux
# Calls the Ansible Agent relay service to trigger provisioning
#

set -euo pipefail

# Configuration file path
CONFIG_FILE="/etc/ansible-agent/config.conf"
LOCK_FILE="/var/run/ansible-agent.lock"
LOG_FILE="/var/log/ansible-agent.log"

# Default values
RELAY_URL=""
INTERVAL_HOURS=24
ENABLED=true

# Function to log messages
log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" | tee -a "$LOG_FILE"
}

# Function to load configuration
load_config() {
    if [[ ! -f "$CONFIG_FILE" ]]; then
        log "ERROR: Configuration file not found: $CONFIG_FILE"
        exit 1
    fi
    
    # Source the configuration file
    source "$CONFIG_FILE"
    
    # Validate required configuration
    if [[ -z "$RELAY_URL" ]]; then
        log "ERROR: RELAY_URL not configured in $CONFIG_FILE"
        exit 1
    fi
    
    if [[ "$ENABLED" != "true" ]]; then
        log "INFO: Agent is disabled in configuration"
        exit 0
    fi
}

# Function to get hostname
get_hostname() {
    hostname -f 2>/dev/null || hostname
}

# Function to calculate delay based on hostname hash
calculate_delay() {
    local hostname="$1"
    local interval_seconds=$((INTERVAL_HOURS * 3600))
    
    # Create hash of hostname and get last 4 hex digits
    local hash=$(echo -n "$hostname" | sha256sum | tail -c 5 | head -c 4)
    
    # Convert hex to decimal and calculate delay
    local hash_decimal=$((16#$hash))
    local delay=$((hash_decimal % interval_seconds))
    
    echo "$delay"
}

# Function to make callback to relay service
make_callback() {
    local hostname="$1"
    local relay_url="$2"
    
    log "INFO: Making callback for hostname: $hostname"
    
    # Make HTTP POST request with hostname
    local response
    local exit_code=0
    
    response=$(curl -s -w "%{http_code}" \
        -X POST \
        -H "Content-Type: application/json" \
        -d "{\"hostname\": \"$hostname\"}" \
        "$relay_url/provision" \
        --connect-timeout 30 \
        --max-time 60) || exit_code=$?
    
    if [[ $exit_code -ne 0 ]]; then
        log "ERROR: Failed to connect to relay service: curl exit code $exit_code"
        return 1
    fi
    
    # Extract HTTP status code (last 3 characters)
    local http_code="${response: -3}"
    local body="${response%???}"
    
    case "$http_code" in
        200)
            log "INFO: Callback successful: $body"
            return 0
            ;;
        429)
            log "WARN: Rate limited by relay service"
            return 0
            ;;
        400)
            log "ERROR: Bad request - invalid hostname format"
            return 1
            ;;
        500)
            log "ERROR: Relay service internal error: $body"
            return 1
            ;;
        *)
            log "ERROR: Unexpected HTTP response code: $http_code, body: $body"
            return 1
            ;;
    esac
}

# Function to check if another instance is running
check_lock() {
    if [[ -f "$LOCK_FILE" ]]; then
        local pid=$(cat "$LOCK_FILE" 2>/dev/null || echo "")
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            log "INFO: Another instance is already running (PID: $pid)"
            exit 0
        else
            log "INFO: Removing stale lock file"
            rm -f "$LOCK_FILE"
        fi
    fi
    
    # Create lock file with current PID
    echo $$ > "$LOCK_FILE"
    
    # Remove lock file on exit
    trap 'rm -f "$LOCK_FILE"' EXIT
}

# Function to run as daemon
run_daemon() {
    log "INFO: Starting Ansible Agent daemon"
    
    while true; do
        local hostname=$(get_hostname)
        local delay=$(calculate_delay "$hostname")
        
        log "INFO: Next callback in $delay seconds (${INTERVAL_HOURS}h interval)"
        sleep "$delay"
        
        # Make the callback
        if make_callback "$hostname" "$RELAY_URL"; then
            log "INFO: Callback completed successfully"
        else
            log "WARN: Callback failed, will retry in next cycle"
        fi
        
        # Calculate remaining time until next full interval
        local interval_seconds=$((INTERVAL_HOURS * 3600))
        local remaining=$((interval_seconds - delay))
        
        if [[ $remaining -gt 0 ]]; then
            log "INFO: Waiting $remaining seconds until next interval"
            sleep "$remaining"
        fi
    done
}

# Function to run once
run_once() {
    local hostname=$(get_hostname)
    log "INFO: Making one-time callback for hostname: $hostname"
    
    if make_callback "$hostname" "$RELAY_URL"; then
        log "INFO: One-time callback completed successfully"
        exit 0
    else
        log "ERROR: One-time callback failed"
        exit 1
    fi
}

# Main function
main() {
    # Ensure log directory exists
    mkdir -p "$(dirname "$LOG_FILE")"
    
    # Load configuration
    load_config
    
    # Check for command line arguments
    case "${1:-daemon}" in
        daemon)
            check_lock
            run_daemon
            ;;
        once)
            run_once
            ;;
        test)
            local hostname=$(get_hostname)
            echo "Hostname: $hostname"
            echo "Relay URL: $RELAY_URL"
            echo "Interval: ${INTERVAL_HOURS}h"
            echo "Delay: $(calculate_delay "$hostname")s"
            exit 0
            ;;
        *)
            echo "Usage: $0 [daemon|once|test]"
            echo "  daemon  - Run as daemon (default)"
            echo "  once    - Make one callback and exit"
            echo "  test    - Test configuration and exit"
            exit 1
            ;;
    esac
}

# Only run main if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi